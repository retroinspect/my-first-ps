## 테스트 케이스
4
1 2
1 4
2 6
4 5
답: 2

3
1 2
3 4
2 3
답: 1

- 강의를 모두 포함해야하기 때문에 '1931 회의실 배정'과는 풀이가 다름
- 시간복잡도 O(N log N) 으로 구현해야 함

## 알고리즘 개요
- 강의들을 시작 시간에 따라 오름차순 정렬, 시작 시간이 같을 경우 종료 시간에 따라 오름차순 정렬하여 첫 번째 강의부터 강의실에 배정한다.
- 현재 각각의 강의실들에 배정한 강의 목록 중 마지막 강의만 고려하자
- 이 강의들 중 가장 종료시간이 빠른 강의를 S라 하자
- 현재 살펴보는 강의 T는 배정되지 않은 모든 강의 중 가장 시작시간이 빠른 강의이다

- S의 종료 시간 <  T의 시작 시간 일 경우, 현재 강의를 위해 강의실을 추가하고 해당 강의실에 T를 배치한다
- 아닐 경우, S가 진행되는 강의실에 T를 배치한다.

이렇게 구한 강의실의 갯수가 k개라고 하자.
추가된 순서에 따라 강의실에 1, ..., k의 번호를 붙이자.

i 번 강의실에서 진행되는 강의의 갯수를 n(i) 라 하면, 각각의 강의에도 추가된 순서에 따라 1, ..., n(i) 의 번호를 붙인다.

s(i, j) 를 i번 강의실에서 j번째로 진행되는 강의라고 하자.

s(i, j)의 시작 시간 < s(i, j)의 종료 시간 <= s(i, j+1)의 시작 시간 이다. 따라서 강의가 추가된 순서는 시작 시간의 오름차순과 같다. --(*)


## 최적해 재배열 증명
- 필요한 강의실 수의 최솟값을 m개라고 하고, 각각의 강의실에서 가장 먼저 진행되는 강의의 시작 시간이 빠른 것부터 1, ..., m의 번호를 붙이자.
- i 번 강의실에서 진행되는 강의의 갯수를 n(i) 라 하면, 시작 시간이 빠른 것부터 1, ..., n(i) 의 번호를 붙인다.
- 마찬가지로 t(i, j) 를 i번 강의실에서 j번째로 진행되는 강의라고 하면, (*)을 만족한다

1번째 강의실에 배정된 강의들을 다른 강의실에 배정된 강의와 교환하여 t'(1, j) = s(1, j) 이 되도록 만들자.

### j = 2 일때의 예시
만약 t(1, 2) = s(1, 2) 라면, 이미 원하는 조건을 만족시켰으므로 넘어간다.
아니라면, 우선 s(1, 2)를 포함한 강의실과, 그 강의실에서 s(1, 2)가 몇 번째 강의인지 알아낸다. 즉, t(a, b) = s(1, 2)를 만족하는 a와 b를 찾는다.

정의상 s(1, 1)의 종료 시간 <= s(1, 2) = t(a, b) 의 시작 시간 < t(1, 2)의 시작 시간 이고,
따라서 t(a, b-1)의 종료 시간 <= s(1, 2) = t(a, b) 의 시작 시간 < t(1, 2)의 시작 시간 이다.

따라서 [t(a, b), t(a, b+1), ..., t(a, n(a))] 와 [t(1, 2), t(1, 3), ..., t(1, n(1))] 을 통째로 바꿔도 강의를 순서대로 모두 진행할 수 있다.

이와 같은 과정을 총 n 번 반복하면 t'(1, j) = s(1, j)로 만들 수 있다.
또한 이와 같은 과정을 총 m 번 반복하면 t(n)(i, j) = s(i, j)로 만들 수 있다.

t를 재배열하여 s로 만들 수 있으므로, m = k이다.